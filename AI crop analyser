"""
AI Crop Analyser - Complete Streamlit app (single-file)

Features included:
- Sensor-data mode: upload CSV or generate synthetic data, training a RandomForest to predict "crop health" (Healthy / Stressed)
- Image inference mode: upload an image and (optionally) upload a pre-trained Keras model (.h5) for image-based prediction
- Renewable-energy recommendation: a simple rule-based recommender (solar irrigation schedule suggestion) based on predictions and weather/sensor inputs
- Model save / download

How to run:
1. Create a new virtual environment (recommended)
   python -m venv venv
   source venv/bin/activate  # mac/linux
   venv\Scripts\activate     # windows
2. Install requirements:
   pip install -r requirements.txt
   (See requirements below)
3. Run app:
   streamlit run AI_Crop_Analyser_Streamlit_App.py

Requirements (requirements.txt):
streamlit
pandas
scikit-learn
matplotlib
numpy
joblib
tensorflow>=2.6  # only required if you want to use image model features
Pillow

Notes:
- The app ships with a synthetic dataset generator so you can train and test without external data.
- Image-based classification requires a Keras (.h5) model compatible with the input size used in the app (224x224). You can optionally train such a model using the sensor+image training pipeline in the repo, or use your own.

"""

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
import matplotlib.pyplot as plt
import joblib
import io
import os
from PIL import Image

# Try-import tensorflow only when needed to keep startup light
try:
    import tensorflow as tf
    from tensorflow.keras.applications import MobileNetV2
    from tensorflow.keras.applications.mobilenet_v2 import preprocess_input
    from tensorflow.keras.preprocessing import image as tf_image
    from tensorflow.keras.models import load_model
    TF_AVAILABLE = True
except Exception:
    TF_AVAILABLE = False

st.set_page_config(page_title="AI Crop Analyser", layout="wide")

st.title("ðŸŒ± AI Crop Analyser â€” Streamlit App")
st.markdown("Use this app to experiment with sensor-data ML models and optional image-based inference. The app also provides simple renewable-energy recommendations (solar irrigation).")

# Sidebar - choose mode
mode = st.sidebar.selectbox("Mode", ["Sensor-data (train & predict)", "Image Inference", "About / Instructions"]) 

##########################
# Helper functions
##########################

def generate_synthetic_dataset(n=1000, random_state=42):
    rng = np.random.RandomState(random_state)
    # features: soil_moisture, temperature_c, humidity_pct, sunlight_lux, ph
    soil_moisture = rng.normal(loc=30, scale=10, size=n)  # percent
    temperature_c = rng.normal(loc=25, scale=5, size=n)
    humidity_pct = rng.normal(loc=60, scale=15, size=n)
    sunlight_lux = rng.normal(loc=50000, scale=20000, size=n)
    ph = rng.normal(loc=6.5, scale=0.7, size=n)

    # Simple rule to define "health": healthy if moisture between 20-40, temp 18-30, ph 5.5-7.5
    healthy = (
        (soil_moisture >= 20) & (soil_moisture <= 40) &
        (temperature_c >= 18) & (temperature_c <= 30) &
        (ph >= 5.5) & (ph <= 7.5)
    )

    # Add noise and some stressed cases due to low sunlight or extreme humidity
    stressed_due_to_sun = sunlight_lux < 20000
    stressed_due_to_humidity = humidity_pct < 30
    label = np.where(healthy & ~stressed_due_to_sun, 'Healthy', 'Stressed')
    label = np.where(stressed_due_to_humidity, 'Stressed', label)

    df = pd.DataFrame({
        'soil_moisture': soil_moisture,
        'temperature_c': temperature_c,
        'humidity_pct': humidity_pct,
        'sunlight_lux': sunlight_lux,
        'ph': ph,
        'label': label
    })
    return df


def recommend_renewable_action(row):
    """Return a simple renewable-energy-based recommendation string based on sensor inputs and predicted label."""
    recs = []
    # Solar irrigation suggestion (if soil_moisture low and sunlight high -> use solar irrigation during peak sun)
    if row['soil_moisture'] < 25:
        if row['sunlight_lux'] > 30000:
            recs.append("Schedule solar-powered irrigation during peak sun hours (10:00â€“14:00).")
        else:
            recs.append("Soil low moisture: consider pumping from stored water (battery-backed solar) or night irrigation if possible.")
    # Ventilation suggestion (if temp high)
    if row['temperature_c'] > 30:
        recs.append("Use wind/solar-assisted ventilation or shading to reduce canopy temperature.")
    # PH corrective suggestion (not energy-specific but actionable)
    if row['ph'] < 5.8:
        recs.append("Soil acidic: apply lime. Consider energy-efficient spreaders or small solar spreader systems.")
    if not recs:
        recs.append("No immediate renewable-action needed. Continue monitoring.")
    return " ".join(recs)

##########################
# Sensor-data Mode
##########################
if mode == "Sensor-data (train & predict)":
    st.header("Sensor data â€” train a model to predict crop health")
    col1, col2 = st.columns([2,1])

    with col1:
        st.subheader("Data input")
        data_option = st.radio("Dataset source", ["Use synthetic demo dataset", "Upload CSV (must have features: soil_moisture, temperature_c, humidity_pct, sunlight_lux, ph, label)"])
        if data_option == 'Use synthetic demo dataset':
            n = st.slider("Number of rows", min_value=200, max_value=5000, value=1000, step=100)
            df = generate_synthetic_dataset(n=n)
            st.success("Synthetic dataset generated")
            st.dataframe(df.head(10))
        else:
            uploaded_file = st.file_uploader("Upload CSV", type=['csv'])
            if uploaded_file is not None:
                df = pd.read_csv(uploaded_file)
                st.success("CSV loaded")
                st.dataframe(df.head(10))
            else:
                st.info("Upload a CSV or choose the demo dataset to proceed.")
                st.stop()

        st.markdown("---")
        st.subheader("Feature selection & preprocessing")
        feature_cols = st.multiselect("Select feature columns", options=[c for c in df.columns if c!='label'], default=['soil_moisture','temperature_c','humidity_pct','sunlight_lux','ph'])
        target_col = st.selectbox("Target column", options=['label'] if 'label' in df.columns else df.columns)

        # Basic cleaning
        df_clean = df[feature_cols + [target_col]].dropna()

    with col2:
        st.subheader("Model & Training options")
        n_estimators = st.slider("n_estimators (RandomForest)", min_value=10, max_value=500, value=100, step=10)
        test_size = st.slider("Test set size (%)", min_value=10, max_value=50, value=20)
        random_state = st.number_input("Random state", value=42, step=1)
        do_train = st.button("Train model")

    if do_train:
        X = df_clean[feature_cols].values
        y = df_clean[target_col].values
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size/100.0, random_state=int(random_state))

        clf = RandomForestClassifier(n_estimators=int(n_estimators), random_state=int(random_state))
        with st.spinner("Training RandomForest..."):
            clf.fit(X_train, y_train)

        y_pred = clf.predict(X_test)
        acc = accuracy_score(y_test, y_pred)
        st.success(f"Training finished â€” test accuracy: {acc:.3f}")

        st.subheader("Classification report")
        report = classification_report(y_test, y_pred, output_dict=True)
        report_df = pd.DataFrame(report).transpose()
        st.dataframe(report_df)

        st.subheader("Confusion matrix")
        cm = confusion_matrix(y_test, y_pred)
        fig, ax = plt.subplots()
        ax.imshow(cm, interpolation='nearest')
        ax.set_title('Confusion matrix')
        ax.set_xlabel('Predicted')
        ax.set_ylabel('True')
        for (i, j), z in np.ndenumerate(cm):
            ax.text(j, i, str(z), ha='center', va='center')
        st.pyplot(fig)

        # Save model
        model_buffer = io.BytesIO()
        joblib.dump(clf, 'sensor_rf_model.joblib')
        st.download_button(label='Download trained RandomForest model (.joblib)', data=open('sensor_rf_model.joblib','rb'), file_name='sensor_rf_model.joblib')

        # Quick prediction panel for single row
        st.markdown('---')
        st.subheader('Quick prediction from manual inputs')
        sample = {}
        for feat in feature_cols:
            sample[feat] = st.number_input(feat, value=float(df_clean[feat].median()))
        if st.button('Predict sample'):
            sample_arr = np.array([sample[feat] for feat in feature_cols]).reshape(1, -1)
            pred = clf.predict(sample_arr)[0]
            st.write('Predicted label:', pred)
            # show recommendation
            row = {**sample}
            row['predicted_label'] = pred
            rec = recommend_renewable_action(row)
            st.info('Renewable-energy recommendation: ' + rec)

##########################
# Image Inference Mode
##########################
elif mode == "Image Inference":
    st.header("Image Inference â€” Upload an image to get predictions")
    if not TF_AVAILABLE:
        st.warning("TensorFlow not available in this environment. Image features will be disabled. Install tensorflow to enable image inference and model loading.")

    uploaded_img = st.file_uploader("Upload crop image (jpg/png)", type=['jpg','jpeg','png'])
    st.markdown('---')
    st.subheader('Optional: Upload a Keras model (.h5) for inference')
    model_file = st.file_uploader('Upload Keras model (.h5)', type=['h5'])

    if uploaded_img is not None:
        img = Image.open(uploaded_img).convert('RGB')
        st.image(img, caption='Uploaded image', use_container_width=True)

        if model_file is not None and TF_AVAILABLE:
            # Save temp file
            with open('uploaded_model.h5', 'wb') as f:
                f.write(model_file.read())
            try:
                model = load_model('uploaded_model.h5')
                st.success('Model loaded')
                # Preprocess image
                img_resized = img.resize((224,224))
                x = tf_image.img_to_array(img_resized)
                x = np.expand_dims(x, axis=0)
                x = preprocess_input(x)
                preds = model.predict(x)
                st.write('Raw model output:', preds)
                # If model outputs probabilities for classes, show argmax
                if preds.ndim == 2 and preds.shape[1] > 1:
                    class_idx = np.argmax(preds, axis=1)[0]
                    st.write(f'Predicted class index: {class_idx} (check your model mapping)')
                else:
                    st.write('Model output might be a regression or single-output value. Interpret accordingly.')
            except Exception as e:
                st.error('Failed to load model: ' + str(e))
        else:
            if model_file is None:
                st.info('Upload a compatible Keras .h5 model to run inference. Alternatively, use the sensor-data model for ML experimentation.')

##########################
# About / Instructions
##########################
else:
    st.header('About â€” AI Crop Analyser')
    st.markdown(
        '''
        This Streamlit app is a single-file starter for an AI-powered crop analyser focusing on renewable-energy-aware recommendations.

        What you get:
        - A simple RandomForest pipeline that trains on sensor data (soil moisture, temp, humidity, sunlight, pH) and predicts Healthy vs Stressed.
        - Rule-based renewable-energy recommendations (solar irrigation suggestions, ventilation hints) based on sensor values and predictions.
        - Ability to download the trained sensor model (.joblib).
        - Image inference stub (upload Keras model) to perform image-based predictions when you have a pretrained model.

        Next steps / improvements you can add:
        - Replace synthetic dataset with your field-collected CSV (timestamped sensor logs + labels).
        - Add time-series models (LSTM) for predicting the trend of crop health.
        - Integrate satellite imagery (NDVI) to improve prediction accuracy.
        - Build a scheduling service to automatically trigger solar pumps using IoT commands.

        If you want, I can:
        - Convert the image pipeline to train a transfer-learning model using MobileNetV2 inside the app.
        - Add geolocation, plotting of sensor history, and exportable reports (PDF).
        - Create a full GitHub repo with README, tests, and CI.
        '''
    )

# Footer
st.markdown('---')
st.caption('AI Crop Analyser â€” starter app. Developed by Archit + ChatGPT (assistant).')
